create table "public"."blocks" (
    "user_id" uuid not null,
    "target_user_id" uuid not null,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."blocks" enable row level security;

create table "public"."categories" (
    "id" bigint generated by default as identity not null,
    "name" character varying not null
);


alter table "public"."categories" enable row level security;

create table "public"."comment_reactions" (
    "comment_id" bigint not null,
    "user_id" uuid not null,
    "is_like" boolean not null,
    "created_at" timestamp with time zone not null default now(),
    "modified_at" timestamp with time zone not null default now()
);


alter table "public"."comment_reactions" enable row level security;

create table "public"."comments" (
    "id" bigint generated by default as identity not null,
    "content" text not null,
    "user_id" uuid not null,
    "thread_id" bigint not null,
    "created_at" timestamp with time zone not null default now(),
    "modified_at" timestamp with time zone not null default now(),
    "filtered_content" text not null
);


alter table "public"."comments" enable row level security;

create table "public"."follows" (
    "user_id" uuid not null,
    "target_user_id" uuid not null,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."follows" enable row level security;

create table "public"."licenses" (
    "id" uuid not null default gen_random_uuid(),
    "is_activated" boolean not null default false,
    "created_at" timestamp with time zone not null default now(),
    "activated_at" timestamp with time zone
);


alter table "public"."licenses" enable row level security;

create table "public"."profiles" (
    "id" uuid not null,
    "username" character varying not null,
    "license_id" uuid not null
);


alter table "public"."profiles" enable row level security;

create table "public"."thread_reactions" (
    "thread_id" bigint not null,
    "user_id" uuid not null,
    "is_like" boolean not null,
    "created_at" timestamp with time zone not null default now(),
    "modified_at" timestamp with time zone not null default now()
);


alter table "public"."thread_reactions" enable row level security;

create table "public"."threads" (
    "id" bigint generated by default as identity not null,
    "title" character varying not null,
    "user_id" uuid not null,
    "category_id" bigint not null,
    "created_at" timestamp with time zone not null default now(),
    "modified_at" timestamp with time zone not null default now()
);


alter table "public"."threads" enable row level security;

CREATE UNIQUE INDEX blocks_pkey ON public.blocks USING btree (user_id, target_user_id);

CREATE UNIQUE INDEX categories_name_key ON public.categories USING btree (name);

CREATE UNIQUE INDEX categories_pkey ON public.categories USING btree (id);

CREATE UNIQUE INDEX comment_reactions_pkey ON public.comment_reactions USING btree (comment_id, user_id);

CREATE UNIQUE INDEX comments_pkey ON public.comments USING btree (id);

CREATE UNIQUE INDEX follows_pkey ON public.follows USING btree (user_id, target_user_id);

CREATE UNIQUE INDEX license_pkey ON public.licenses USING btree (id);

CREATE UNIQUE INDEX profiles_license_id_key ON public.profiles USING btree (license_id);

CREATE UNIQUE INDEX thread_reactions_pkey ON public.thread_reactions USING btree (thread_id, user_id);

CREATE UNIQUE INDEX threads_pkey ON public.threads USING btree (id);

CREATE UNIQUE INDEX users_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX users_username_key ON public.profiles USING btree (username);

alter table "public"."blocks" add constraint "blocks_pkey" PRIMARY KEY using index "blocks_pkey";

alter table "public"."categories" add constraint "categories_pkey" PRIMARY KEY using index "categories_pkey";

alter table "public"."comment_reactions" add constraint "comment_reactions_pkey" PRIMARY KEY using index "comment_reactions_pkey";

alter table "public"."comments" add constraint "comments_pkey" PRIMARY KEY using index "comments_pkey";

alter table "public"."follows" add constraint "follows_pkey" PRIMARY KEY using index "follows_pkey";

alter table "public"."licenses" add constraint "license_pkey" PRIMARY KEY using index "license_pkey";

alter table "public"."profiles" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "public"."thread_reactions" add constraint "thread_reactions_pkey" PRIMARY KEY using index "thread_reactions_pkey";

alter table "public"."threads" add constraint "threads_pkey" PRIMARY KEY using index "threads_pkey";

alter table "public"."blocks" add constraint "blocks_target_user_id_fkey" FOREIGN KEY (target_user_id) REFERENCES profiles(id) not valid;

alter table "public"."blocks" validate constraint "blocks_target_user_id_fkey";

alter table "public"."blocks" add constraint "blocks_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) not valid;

alter table "public"."blocks" validate constraint "blocks_user_id_fkey";

alter table "public"."categories" add constraint "categories_name_key" UNIQUE using index "categories_name_key";

alter table "public"."comment_reactions" add constraint "comment_reactions_comment_id_fkey" FOREIGN KEY (comment_id) REFERENCES comments(id) not valid;

alter table "public"."comment_reactions" validate constraint "comment_reactions_comment_id_fkey";

alter table "public"."comment_reactions" add constraint "comment_reactions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) not valid;

alter table "public"."comment_reactions" validate constraint "comment_reactions_user_id_fkey";

alter table "public"."comments" add constraint "comments_thread_id_fkey" FOREIGN KEY (thread_id) REFERENCES threads(id) not valid;

alter table "public"."comments" validate constraint "comments_thread_id_fkey";

alter table "public"."comments" add constraint "comments_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) not valid;

alter table "public"."comments" validate constraint "comments_user_id_fkey";

alter table "public"."comments" add constraint "comments_user_id_fkey1" FOREIGN KEY (user_id) REFERENCES profiles(id) not valid;

alter table "public"."comments" validate constraint "comments_user_id_fkey1";

alter table "public"."follows" add constraint "follows_target_user_id_fkey" FOREIGN KEY (target_user_id) REFERENCES profiles(id) not valid;

alter table "public"."follows" validate constraint "follows_target_user_id_fkey";

alter table "public"."follows" add constraint "follows_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) not valid;

alter table "public"."follows" validate constraint "follows_user_id_fkey";

alter table "public"."profiles" add constraint "profiles_license_id_fkey" FOREIGN KEY (license_id) REFERENCES licenses(id) not valid;

alter table "public"."profiles" validate constraint "profiles_license_id_fkey";

alter table "public"."profiles" add constraint "profiles_license_id_key" UNIQUE using index "profiles_license_id_key";

alter table "public"."profiles" add constraint "users_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) not valid;

alter table "public"."profiles" validate constraint "users_id_fkey";

alter table "public"."profiles" add constraint "users_id_fkey1" FOREIGN KEY (id) REFERENCES auth.users(id) not valid;

alter table "public"."profiles" validate constraint "users_id_fkey1";

alter table "public"."profiles" add constraint "users_username_key" UNIQUE using index "users_username_key";

alter table "public"."thread_reactions" add constraint "thread_reactions_thread_id_fkey" FOREIGN KEY (thread_id) REFERENCES threads(id) not valid;

alter table "public"."thread_reactions" validate constraint "thread_reactions_thread_id_fkey";

alter table "public"."thread_reactions" add constraint "thread_reactions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) not valid;

alter table "public"."thread_reactions" validate constraint "thread_reactions_user_id_fkey";

alter table "public"."threads" add constraint "threads_category_id_fkey" FOREIGN KEY (category_id) REFERENCES categories(id) not valid;

alter table "public"."threads" validate constraint "threads_category_id_fkey";

alter table "public"."threads" add constraint "threads_user_id_fkey1" FOREIGN KEY (user_id) REFERENCES profiles(id) not valid;

alter table "public"."threads" validate constraint "threads_user_id_fkey1";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_comments_in_thread_with_counts(current_thread_id integer, return_limit integer, return_offset integer, current_user_id uuid DEFAULT NULL::uuid)
 RETURNS TABLE(id bigint, content text, user_id uuid, thread_id bigint, created_at timestamp with time zone, modified_at timestamp with time zone, username character varying, "like" bigint, dislike bigint, user_reaction text)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    c.id::bigint,
    CASE 
      WHEN current_user_id IS NOT NULL THEN c.content
      ELSE c.filtered_content
    END AS content,
    c.user_id,
    c.thread_id,
    c.created_at,
    c.modified_at,
    u.username,
    COUNT(CASE WHEN cr.is_like THEN 1 END) AS like,
    COUNT(CASE WHEN NOT cr.is_like THEN 1 END) AS dislike,
    CASE 
      WHEN current_user_id IS NOT NULL THEN (
        SELECT 
          CASE 
            WHEN cr_user.is_like THEN 'like'
            ELSE 'dislike'
          END
        FROM comment_reactions cr_user
        WHERE cr_user.comment_id = c.id 
          AND cr_user.user_id = current_user_id
        LIMIT 1
      )
      ELSE NULL
    END AS user_reaction
  FROM 
    comments c
  LEFT JOIN profiles u ON c.user_id = u.id
  LEFT JOIN comment_reactions cr ON c.id = cr.comment_id
  WHERE 
    c.thread_id = current_thread_id
  GROUP BY 
    c.id, u.username
  ORDER BY 
    c.created_at ASC
  LIMIT return_limit
  OFFSET return_offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_following_threads_count(current_user_id uuid DEFAULT NULL::uuid)
 RETURNS bigint
 LANGUAGE plpgsql
AS $function$
DECLARE
  thread_count bigint;
BEGIN
  SELECT COUNT(*) INTO thread_count
  FROM threads t
  INNER JOIN follows f ON f.target_user_id = t.user_id
  WHERE f.user_id = current_user_id;
  
  RETURN thread_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_following_threads_with_counts(return_limit integer, return_offset integer, current_user_id uuid DEFAULT NULL::uuid, sort_by text DEFAULT 'time'::text)
 RETURNS TABLE(id bigint, title character varying, user_id uuid, category_id bigint, created_at timestamp with time zone, modified_at timestamp with time zone, username character varying, "like" bigint, dislike bigint, user_reaction text)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    t.id::bigint,
    t.title,
    t.user_id,
    t.category_id,
    t.created_at,
    t.modified_at,
    u.username,
    COUNT(CASE WHEN tr.is_like THEN 1 END) AS like, -- Count the number of likes
    COUNT(CASE WHEN NOT tr.is_like THEN 1 END) AS dislike, -- Count the number of dislikes
    CASE -- Get the reaction from the current user
      WHEN current_user_id IS NOT NULL THEN (
        SELECT 
          CASE 
            WHEN tr_user.is_like THEN 'like'
            ELSE 'dislike'
          END
        FROM thread_reactions tr_user
        WHERE tr_user.thread_id = t.id AND tr_user.user_id = current_user_id
        LIMIT 1
      )
      ELSE NULL
    END AS user_reaction
  FROM 
    threads t
  LEFT JOIN profiles u ON t.user_id = u.id
  LEFT JOIN thread_reactions tr ON t.id = tr.thread_id
  INNER JOIN follows f ON f.target_user_id = t.user_id -- Add join condition for follows table
  WHERE 
    f.user_id = current_user_id -- Filter threads from users that the current user is following
  GROUP BY 
    t.id, u.username
  ORDER BY 
    CASE 
      WHEN sort_by = 'likes' THEN COUNT(CASE WHEN tr.is_like THEN 1 END)
      ELSE NULL -- Used for fallback
    END DESC, -- Sort by likes if 'sort_by' is 'likes'
    CASE 
      WHEN sort_by = 'likes' THEN COUNT(CASE WHEN NOT tr.is_like THEN 1 END)
      ELSE NULL -- Used for fallback
    END ASC, -- Sort by likes if 'sort_by' is 'likes'
    CASE 
      WHEN sort_by = 'time' THEN t.created_at
    END DESC -- Sort by time if 'sort_by' is 'time'
  LIMIT return_limit OFFSET return_offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_threads_with_counts(current_category_id integer, return_limit integer, return_offset integer DEFAULT 0, current_user_id uuid DEFAULT NULL::uuid, sort_by text DEFAULT 'time'::text)
 RETURNS TABLE(id bigint, title character varying, user_id uuid, category_id bigint, created_at timestamp with time zone, modified_at timestamp with time zone, username character varying, "like" bigint, dislike bigint, user_reaction text)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    t.id::bigint,
    t.title,
    t.user_id,
    t.category_id,
    t.created_at,
    t.modified_at,
    u.username,
    COUNT(CASE WHEN tr.is_like THEN 1 END) AS like, -- Count the number of likes
    COUNT(CASE WHEN NOT tr.is_like THEN 1 END) AS dislike, -- Count the number of dislike
    CASE -- get the reaction from the current user
      WHEN current_user_id IS NOT NULL THEN (
        SELECT 
          CASE 
            WHEN tr_user.is_like THEN 'like'
            ELSE 'dislike'
          END
        FROM thread_reactions tr_user
        WHERE tr_user.thread_id = t.id AND tr_user.user_id = current_user_id
        LIMIT 1
      )
      ELSE NULL
    END AS user_reaction
  FROM 
    threads t
  LEFT JOIN profiles u ON t.user_id = u.id
  LEFT JOIN thread_reactions tr ON t.id = tr.thread_id
  WHERE 
    t.category_id = current_category_id
  GROUP BY 
    t.id, u.username
  ORDER BY 
    CASE 
      WHEN sort_by = 'likes' THEN COUNT(CASE WHEN tr.is_like THEN 1 END)
      ELSE NULL -- Used for fallback
    END DESC, -- Sort by likes if 'sort_by' is 'likes'
    CASE 
      WHEN sort_by = 'likes' THEN COUNT(CASE WHEN NOT tr.is_like THEN 1 END)
      ELSE NULL -- Used for fallback
    END ASC, -- Sort by likes if 'sort_by' is 'likes'
    CASE 
      WHEN sort_by = 'time' THEN t.created_at
    END DESC -- Sort by time if 'sort_by' is 'time'
  LIMIT return_limit OFFSET return_offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_threads_with_counts(return_limit integer, current_user_id uuid)
 RETURNS TABLE(id bigint, title character varying, user_id uuid, category_id bigint, created_at timestamp with time zone, modified_at timestamp with time zone, username character varying, "like" bigint, dislike bigint, user_reaction text)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    t.id::bigint,
    t.title,
    t.user_id,
    t.category_id,
    t.created_at,
    t.modified_at,
    u.username,
    COUNT(CASE WHEN tr.is_like THEN 1 END) AS like,
    COUNT(CASE WHEN NOT tr.is_like THEN 1 END) AS dislike,
    CASE 
      WHEN current_user_id IS NOT NULL THEN (
        SELECT 
          CASE 
            WHEN tr_user.is_like THEN 'like'
            ELSE 'dislike'
          END
        FROM thread_reactions tr_user
        WHERE tr_user.thread_id = t.id AND tr_user.user_id = current_user_id
        LIMIT 1
      )
      ELSE NULL
    END AS user_reaction
  FROM 
    threads t
  LEFT JOIN profiles u ON t.user_id = u.id
  LEFT JOIN thread_reactions tr ON t.id = tr.thread_id
  WHERE 
    t.user_id = current_user_id
  GROUP BY 
    t.id, u.username
  ORDER BY 
    CASE 
      WHEN sort_by = 'likes' THEN COUNT(CASE WHEN tr.is_like THEN 1 END)
      ELSE NULL -- Used for fallback
    END DESC, -- Sort by likes if 'sort_by' is 'likes'
    COUNT(CASE WHEN NOT tr.is_like THEN 1 END) ASC, -- Secondary sort by dislikes (less is better)
    CASE 
      WHEN sort_by = 'time' THEN t.created_at
    END DESC -- Sort by time if 'sort_by' is 'time'
  LIMIT return_limit;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_threads_with_counts(return_limit integer, current_user_id uuid, sort_by text DEFAULT 'time'::text)
 RETURNS TABLE(id bigint, title character varying, user_id uuid, category_id bigint, created_at timestamp with time zone, modified_at timestamp with time zone, username character varying, "like" bigint, dislike bigint, user_reaction text)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    t.id::bigint,
    t.title,
    t.user_id,
    t.category_id,
    t.created_at,
    t.modified_at,
    u.username,
    COUNT(CASE WHEN tr.is_like THEN 1 END) AS like,
    COUNT(CASE WHEN NOT tr.is_like THEN 1 END) AS dislike,
    CASE 
      WHEN current_user_id IS NOT NULL THEN (
        SELECT 
          CASE 
            WHEN tr_user.is_like THEN 'like'
            ELSE 'dislike'
          END
        FROM thread_reactions tr_user
        WHERE tr_user.thread_id = t.id AND tr_user.user_id = current_user_id
        LIMIT 1
      )
      ELSE NULL
    END AS user_reaction
  FROM 
    threads t
  LEFT JOIN profiles u ON t.user_id = u.id
  LEFT JOIN thread_reactions tr ON t.id = tr.thread_id
  WHERE 
    t.user_id = current_user_id
  GROUP BY 
    t.id, u.username
  ORDER BY 
    CASE 
      WHEN sort_by = 'likes' THEN COUNT(CASE WHEN tr.is_like THEN 1 END)
      ELSE NULL -- Used for fallback
    END DESC, -- Sort by likes if 'sort_by' is 'likes'
    COUNT(CASE WHEN NOT tr.is_like THEN 1 END) ASC, -- Secondary sort by dislikes (less is better)
    CASE 
      WHEN sort_by = 'time' THEN t.created_at
    END DESC -- Sort by time if 'sort_by' is 'time'
  LIMIT return_limit;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_threads_with_counts(return_limit integer, return_offset integer, current_user_id uuid, sort_by text DEFAULT 'time'::text)
 RETURNS TABLE(id bigint, title character varying, user_id uuid, category_id bigint, created_at timestamp with time zone, modified_at timestamp with time zone, username character varying, "like" bigint, dislike bigint, user_reaction text)
 LANGUAGE plpgsql
AS $function$

BEGIN
  RETURN QUERY
  SELECT 
    t.id::bigint,
    t.title,
    t.user_id,
    t.category_id,
    t.created_at,
    t.modified_at,
    u.username,
    COUNT(CASE WHEN tr.is_like THEN 1 END) AS like,
    COUNT(CASE WHEN NOT tr.is_like THEN 1 END) AS dislike,
    CASE 
      WHEN current_user_id IS NOT NULL THEN (
        SELECT 
          CASE 
            WHEN tr_user.is_like THEN 'like'
            ELSE 'dislike'
          END
        FROM thread_reactions tr_user
        WHERE tr_user.thread_id = t.id AND tr_user.user_id = current_user_id
        LIMIT 1
      )
      ELSE NULL
    END AS user_reaction
  FROM 
    threads t
  LEFT JOIN profiles u ON t.user_id = u.id
  LEFT JOIN thread_reactions tr ON t.id = tr.thread_id
  WHERE 
    t.user_id = current_user_id
  GROUP BY 
    t.id, u.username
  ORDER BY 
    CASE 
      WHEN sort_by = 'likes' THEN COUNT(CASE WHEN tr.is_like THEN 1 END)
      ELSE NULL -- Used for fallback
    END DESC, -- Sort by likes if 'sort_by' is 'likes'
    COUNT(CASE WHEN NOT tr.is_like THEN 1 END) ASC, -- Secondary sort by dislikes (less is better)
    CASE 
      WHEN sort_by = 'time' THEN t.created_at
    END DESC -- Sort by time if 'sort_by' is 'time'
  LIMIT return_limit OFFSET return_offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare 
  existing_count int;
begin
    -- Check if the username already exists
  select count(*) into existing_count
  from public.profiles
  where username = new.raw_user_meta_data->>'username';

  if existing_count > 0 then
    raise exception 'Username "%" is already taken', new.raw_user_meta_data->>'username';
  end if;
  
  update public.licenses
  set is_activated = true, activated_at = now()
  where id = (new.raw_user_meta_data->>'license_id')::uuid;
  
  insert into public.profiles (id, username, license_id)
  values (new.id, new.raw_user_meta_data->>'username', (new.raw_user_meta_data->>'license_id')::uuid);
  return new;

  -- insert into public.profiles (id, username)
  -- values (new.id, new.raw_user_meta_data->>'username');
  -- return new;
end;
$function$
;

grant delete on table "public"."blocks" to "anon";

grant insert on table "public"."blocks" to "anon";

grant references on table "public"."blocks" to "anon";

grant select on table "public"."blocks" to "anon";

grant trigger on table "public"."blocks" to "anon";

grant truncate on table "public"."blocks" to "anon";

grant update on table "public"."blocks" to "anon";

grant delete on table "public"."blocks" to "authenticated";

grant insert on table "public"."blocks" to "authenticated";

grant references on table "public"."blocks" to "authenticated";

grant select on table "public"."blocks" to "authenticated";

grant trigger on table "public"."blocks" to "authenticated";

grant truncate on table "public"."blocks" to "authenticated";

grant update on table "public"."blocks" to "authenticated";

grant delete on table "public"."blocks" to "service_role";

grant insert on table "public"."blocks" to "service_role";

grant references on table "public"."blocks" to "service_role";

grant select on table "public"."blocks" to "service_role";

grant trigger on table "public"."blocks" to "service_role";

grant truncate on table "public"."blocks" to "service_role";

grant update on table "public"."blocks" to "service_role";

grant delete on table "public"."categories" to "anon";

grant insert on table "public"."categories" to "anon";

grant references on table "public"."categories" to "anon";

grant select on table "public"."categories" to "anon";

grant trigger on table "public"."categories" to "anon";

grant truncate on table "public"."categories" to "anon";

grant update on table "public"."categories" to "anon";

grant delete on table "public"."categories" to "authenticated";

grant insert on table "public"."categories" to "authenticated";

grant references on table "public"."categories" to "authenticated";

grant select on table "public"."categories" to "authenticated";

grant trigger on table "public"."categories" to "authenticated";

grant truncate on table "public"."categories" to "authenticated";

grant update on table "public"."categories" to "authenticated";

grant delete on table "public"."categories" to "service_role";

grant insert on table "public"."categories" to "service_role";

grant references on table "public"."categories" to "service_role";

grant select on table "public"."categories" to "service_role";

grant trigger on table "public"."categories" to "service_role";

grant truncate on table "public"."categories" to "service_role";

grant update on table "public"."categories" to "service_role";

grant delete on table "public"."comment_reactions" to "anon";

grant insert on table "public"."comment_reactions" to "anon";

grant references on table "public"."comment_reactions" to "anon";

grant select on table "public"."comment_reactions" to "anon";

grant trigger on table "public"."comment_reactions" to "anon";

grant truncate on table "public"."comment_reactions" to "anon";

grant update on table "public"."comment_reactions" to "anon";

grant delete on table "public"."comment_reactions" to "authenticated";

grant insert on table "public"."comment_reactions" to "authenticated";

grant references on table "public"."comment_reactions" to "authenticated";

grant select on table "public"."comment_reactions" to "authenticated";

grant trigger on table "public"."comment_reactions" to "authenticated";

grant truncate on table "public"."comment_reactions" to "authenticated";

grant update on table "public"."comment_reactions" to "authenticated";

grant delete on table "public"."comment_reactions" to "service_role";

grant insert on table "public"."comment_reactions" to "service_role";

grant references on table "public"."comment_reactions" to "service_role";

grant select on table "public"."comment_reactions" to "service_role";

grant trigger on table "public"."comment_reactions" to "service_role";

grant truncate on table "public"."comment_reactions" to "service_role";

grant update on table "public"."comment_reactions" to "service_role";

grant delete on table "public"."comments" to "anon";

grant insert on table "public"."comments" to "anon";

grant references on table "public"."comments" to "anon";

grant select on table "public"."comments" to "anon";

grant trigger on table "public"."comments" to "anon";

grant truncate on table "public"."comments" to "anon";

grant update on table "public"."comments" to "anon";

grant delete on table "public"."comments" to "authenticated";

grant insert on table "public"."comments" to "authenticated";

grant references on table "public"."comments" to "authenticated";

grant select on table "public"."comments" to "authenticated";

grant trigger on table "public"."comments" to "authenticated";

grant truncate on table "public"."comments" to "authenticated";

grant update on table "public"."comments" to "authenticated";

grant delete on table "public"."comments" to "service_role";

grant insert on table "public"."comments" to "service_role";

grant references on table "public"."comments" to "service_role";

grant select on table "public"."comments" to "service_role";

grant trigger on table "public"."comments" to "service_role";

grant truncate on table "public"."comments" to "service_role";

grant update on table "public"."comments" to "service_role";

grant delete on table "public"."follows" to "anon";

grant insert on table "public"."follows" to "anon";

grant references on table "public"."follows" to "anon";

grant select on table "public"."follows" to "anon";

grant trigger on table "public"."follows" to "anon";

grant truncate on table "public"."follows" to "anon";

grant update on table "public"."follows" to "anon";

grant delete on table "public"."follows" to "authenticated";

grant insert on table "public"."follows" to "authenticated";

grant references on table "public"."follows" to "authenticated";

grant select on table "public"."follows" to "authenticated";

grant trigger on table "public"."follows" to "authenticated";

grant truncate on table "public"."follows" to "authenticated";

grant update on table "public"."follows" to "authenticated";

grant delete on table "public"."follows" to "service_role";

grant insert on table "public"."follows" to "service_role";

grant references on table "public"."follows" to "service_role";

grant select on table "public"."follows" to "service_role";

grant trigger on table "public"."follows" to "service_role";

grant truncate on table "public"."follows" to "service_role";

grant update on table "public"."follows" to "service_role";

grant delete on table "public"."licenses" to "anon";

grant insert on table "public"."licenses" to "anon";

grant references on table "public"."licenses" to "anon";

grant select on table "public"."licenses" to "anon";

grant trigger on table "public"."licenses" to "anon";

grant truncate on table "public"."licenses" to "anon";

grant update on table "public"."licenses" to "anon";

grant delete on table "public"."licenses" to "authenticated";

grant insert on table "public"."licenses" to "authenticated";

grant references on table "public"."licenses" to "authenticated";

grant select on table "public"."licenses" to "authenticated";

grant trigger on table "public"."licenses" to "authenticated";

grant truncate on table "public"."licenses" to "authenticated";

grant update on table "public"."licenses" to "authenticated";

grant delete on table "public"."licenses" to "service_role";

grant insert on table "public"."licenses" to "service_role";

grant references on table "public"."licenses" to "service_role";

grant select on table "public"."licenses" to "service_role";

grant trigger on table "public"."licenses" to "service_role";

grant truncate on table "public"."licenses" to "service_role";

grant update on table "public"."licenses" to "service_role";

grant delete on table "public"."profiles" to "anon";

grant insert on table "public"."profiles" to "anon";

grant references on table "public"."profiles" to "anon";

grant select on table "public"."profiles" to "anon";

grant trigger on table "public"."profiles" to "anon";

grant truncate on table "public"."profiles" to "anon";

grant update on table "public"."profiles" to "anon";

grant delete on table "public"."profiles" to "authenticated";

grant insert on table "public"."profiles" to "authenticated";

grant references on table "public"."profiles" to "authenticated";

grant select on table "public"."profiles" to "authenticated";

grant trigger on table "public"."profiles" to "authenticated";

grant truncate on table "public"."profiles" to "authenticated";

grant update on table "public"."profiles" to "authenticated";

grant delete on table "public"."profiles" to "service_role";

grant insert on table "public"."profiles" to "service_role";

grant references on table "public"."profiles" to "service_role";

grant select on table "public"."profiles" to "service_role";

grant trigger on table "public"."profiles" to "service_role";

grant truncate on table "public"."profiles" to "service_role";

grant update on table "public"."profiles" to "service_role";

grant delete on table "public"."thread_reactions" to "anon";

grant insert on table "public"."thread_reactions" to "anon";

grant references on table "public"."thread_reactions" to "anon";

grant select on table "public"."thread_reactions" to "anon";

grant trigger on table "public"."thread_reactions" to "anon";

grant truncate on table "public"."thread_reactions" to "anon";

grant update on table "public"."thread_reactions" to "anon";

grant delete on table "public"."thread_reactions" to "authenticated";

grant insert on table "public"."thread_reactions" to "authenticated";

grant references on table "public"."thread_reactions" to "authenticated";

grant select on table "public"."thread_reactions" to "authenticated";

grant trigger on table "public"."thread_reactions" to "authenticated";

grant truncate on table "public"."thread_reactions" to "authenticated";

grant update on table "public"."thread_reactions" to "authenticated";

grant delete on table "public"."thread_reactions" to "service_role";

grant insert on table "public"."thread_reactions" to "service_role";

grant references on table "public"."thread_reactions" to "service_role";

grant select on table "public"."thread_reactions" to "service_role";

grant trigger on table "public"."thread_reactions" to "service_role";

grant truncate on table "public"."thread_reactions" to "service_role";

grant update on table "public"."thread_reactions" to "service_role";

grant delete on table "public"."threads" to "anon";

grant insert on table "public"."threads" to "anon";

grant references on table "public"."threads" to "anon";

grant select on table "public"."threads" to "anon";

grant trigger on table "public"."threads" to "anon";

grant truncate on table "public"."threads" to "anon";

grant update on table "public"."threads" to "anon";

grant delete on table "public"."threads" to "authenticated";

grant insert on table "public"."threads" to "authenticated";

grant references on table "public"."threads" to "authenticated";

grant select on table "public"."threads" to "authenticated";

grant trigger on table "public"."threads" to "authenticated";

grant truncate on table "public"."threads" to "authenticated";

grant update on table "public"."threads" to "authenticated";

grant delete on table "public"."threads" to "service_role";

grant insert on table "public"."threads" to "service_role";

grant references on table "public"."threads" to "service_role";

grant select on table "public"."threads" to "service_role";

grant trigger on table "public"."threads" to "service_role";

grant truncate on table "public"."threads" to "service_role";

grant update on table "public"."threads" to "service_role";

create policy "Enable delete for authenticated users only"
on "public"."blocks"
as permissive
for delete
to authenticated
using (true);


create policy "Enable insert for authenticated users only"
on "public"."blocks"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable select for authenticated users only"
on "public"."blocks"
as permissive
for select
to authenticated
using (true);


create policy "Enable update for authenticated users only"
on "public"."blocks"
as permissive
for update
to authenticated
using (true);


create policy "Enable read access for all users"
on "public"."categories"
as permissive
for select
to public
using (true);


create policy "Enable delete for authenticated users only"
on "public"."comment_reactions"
as permissive
for delete
to authenticated
using (true);


create policy "Enable insert for authenticated users only"
on "public"."comment_reactions"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."comment_reactions"
as permissive
for select
to public
using (true);


create policy "Enable update for authenticated users only"
on "public"."comment_reactions"
as permissive
for update
to authenticated
using (true);


create policy "Enable insert for authenticated users only"
on "public"."comments"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."comments"
as permissive
for select
to public
using (true);


create policy "Enable delete for authenticated users only"
on "public"."follows"
as permissive
for delete
to authenticated
using (true);


create policy "Enable insert for authenticated users only"
on "public"."follows"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable select for authenticated users only"
on "public"."follows"
as permissive
for select
to authenticated
using (true);


create policy "Enable update for authenticated users only"
on "public"."follows"
as permissive
for update
to authenticated
using (true);


create policy "Enable read access for all users"
on "public"."profiles"
as permissive
for select
to public
using (true);


create policy "Public profiles are viewable by everyone."
on "public"."profiles"
as permissive
for select
to public
using (true);


create policy "Users can insert their own profile."
on "public"."profiles"
as permissive
for insert
to public
with check ((( SELECT auth.uid() AS uid) = id));


create policy "Users can update own profile."
on "public"."profiles"
as permissive
for update
to public
using ((( SELECT auth.uid() AS uid) = id));


create policy "Enable delete for authenticated users only"
on "public"."thread_reactions"
as permissive
for delete
to authenticated
using (true);


create policy "Enable insert for authenticated users only"
on "public"."thread_reactions"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."thread_reactions"
as permissive
for select
to public
using (true);


create policy "Enable update for authenticated users only"
on "public"."thread_reactions"
as permissive
for update
to authenticated
using (true);


create policy "Enable insert for authenticated users only"
on "public"."threads"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."threads"
as permissive
for select
to public
using (true);



